
function singularCon_(elemento){ -- agrega los corchetes para la lista
        /*
            Proposito: Describe la lista **elemento** 
            que contiene solo un elemento
            Precondicion: ninguna
            Tipo: Lista de **elemento**
            Parametro: elemento : elemento
        */
    
    return (
         [elemento]
        )
}

function segundoDe_(elemento){
    /*
        Proposito: Describe el segundo elemento **elemento** 
        Precondicion: Debe haber al menos dos elementos dentro de la lista.
        Tipo: **elemento**
        Parametro: elemento : elemento
    */
    
    return( 
       primero(resto(elemento))
        )
}

function esSingular_(lista){
    /*
        Proposito: Indica si la lista **lista** tiene un sólo elemento
        Precondicion: Ninguna
        Tipo: lista 
        Parametro: lista: lista de elemento
    */
    return(
        not esVacía(lista) && esVacía(resto(lista))
        )
}


-------------------------------------------------------------------------------
--primerCartaDeLaMano_, que dada una “mano” describa la primera carta a juga



function primerCartaDeLaMano_(mano){
    
    /*
        Proposito: Describe la primera carta a jugar de la mano ** mano** 
        Precondicion: Ninguna
        Tipo: carta
        Paramatro: mano: lista de carta
    */
    
    return(
        primero(mano)
        )
}


function segundaCartaDeLaMano_(mano){
    /*
        Proposito: Describe la segunda carta de la mano **mano**
        Precondicion: Ninguna
        Tipo: carta
        Parametro: mano: lista de carta
    */
    
    return(
        segundoDe_(mano)
        )
}


function tercerCartaDeLaMano_(mano){
    /*
        Proposito: Describe la tercera carta de la mano **mano**
        Precondicion: ninguna
        Tipo: carta
        Parametro: mano: lista de carta
    */
    return (
        
       primero(resto(resto(mano)))

        )
}

// resultante luego de robar la primera carta
// del mazo y agregarla a la mano del jugador.


function laMano_LuegoDeRobarUnaCartaDe_(mano, mazo){
    
        /*
            Proposito: Describe la mano **mano** despues de robar 
            la primera carta del mazo **mazo**
            Precondicion: Ninguna
            Tipo: lista de carta
            parametro: mano: lista de carta
                       mazo: lista de carta
        */
        
    return (
        
        mano ++ primero([mazo])
        
        )
}



function laMano_LuegoDeJugarUnaCarta(mano){
    /*
        Proposito: Describe la mano **mano** despues de tirar la carta
        más proxima
        Precondicion: Ninguna
        Tipo: Lista de carta
        Parametro: mano : lista de carta
    */
    return(
        
        resto(mano)
        
        )
}


function laMano_LuegoDeJugarLaSegundaCarta(mano){
    /*
        Proposito: Describe la mano **mano** luego de haber
        jugado la segunda carta
        Precondicion: Debe haber al menos 2 cartas en la mano
        Tipo: lista de carta
        Parametro: mano : lista de carta
    */
    
    return (
        
     [primero(mano)] ++ resto(resto(mano))
       
        )
}

------------------------------------------------------------------------------------------------



--lista desde hasta





--totalizacion de resultado
function longitudDe_(lista){
    /*
        Proposito: Describe la cantidad de elementos que
        hay dentro de la lista **lista**
        Precondicion: ninguna
        Tipo: numero
        parametro: lista : lista de elementos
    */
    
    listaActual := lista
    cantidadDeElementosVistos := 0
    
    while(not esVacía(listaActual)){
        
        cantidadDeElementosVistos := cantidadDeElementosVistos + 1
        listaActual := sinElPrimero(listaActual) 
    }
    return(cantidadDeElementosVistos)
}



function sumatoriaDe_(listaNumero){
    /*
        Proposito: Describe la suma de todos los elementos de
        la lista **listaNumero**
        Precondicion: Ninguna
        Tipo: numero
        Parametro: listaNumero : elemento : lista de numero
    */
    
    cantidadTotalDeSuma := 0
    
    foreach numero in listaNumero{
        
        cantidadTotalDeSuma := cantidadTotalDeSuma + numero
        
    }
    return (cantidadTotalDeSuma )
}



function productoriaDe_(listaNumero){
    /*
        Proposito. Describe el producto de todos los elementos de 
        **listaNumero**
        Precondicion: Ninguna
        Tipo: numero
        Parametro: listaNumero : numero : lista de numero
    */
    cantidadTotalDeProducto := primero(listaNumero)
    
    foreach numero in listaNumero{
        
        cantidadTotalDeProducto := cantidadTotalDeProducto * numero
        
    }
    return (cantidadTotalDeProducto )
    
}







function elementosDe_aumentadosEn_(listaDeNumeros, cantidadAumentar) {
    /*
        Proposito: describe la lista **listaDeNumero** con sus
        elementos aumentados en **cantidadAumentar**
        Precondicion: Ninguna
        Tipo: lista de numeros
        Parametro: listaDeNumeros : lista con elementos "numero"
        cantidadAumentar : numero
    */
    
    elementosAumentadosYaVistos := []
    
    foreach numero in listaDeNumeros {
        
      elementosAumentadosYaVistos := elementosAumentadosYaVistos ++
      [numero + cantidadAumentar]
    }
    
    return(elementosAumentadosYaVistos)
}

function paresDe_(listaDeNumeros){
    /*
        Proposito: Describe una lista con numeros pares contenidos
        en la lista **listaDeNumeros**
        Precondicion: Ninguna
        Tipo: Lista de numeros
        Parametro: listaDeNumeros : lista con elementos "numero"
    */
    
    listaDeNumerosParesAhora := []
    
    foreach numero in listaDeNumeros {
        
        listaDeNumerosParesAhora := listaDeNumerosParesAhora ++ 
                singular_Si_(numero, (numero mod 2) == 0)
    }
    return ( listaDeNumerosParesAhora )
}
------------------------------------------------------------

--biblioteca
function singular_Si_(elemento, condicion){
    /*
        Proposito: Describe la lista singular con el
        elemento dado si la condicion dada es verdadera, o la lista vacia
        en caso contrario.
        Precondicion: ninguna
        Parametro: elemento : "elemento"
        condicion: booleano
        Tipo: lista de "elemento"
    */
    
     return (  choose [elemento] when (condicion)
           [] otherwise
     )

} 

--busqueda sin saber si esta
--21 <3)
function contiene_A_(listaDeElemento, elemento){
    /*
        Proposito: Indica si la lista **listaDeElemento** 
        contiene a **elemento**
    */
    
    elementosPorRecorrer := listaDeElemento
    
    while( not esVacía(elementosPorRecorrer) &&
        primero(elementosPorRecorrer) /= elemento) {
        elementosPorRecorrer := sinElPrimero(elementosPorRecorrer)
    }
    
    return ( not esVacía(elementosPorRecorrer) )
    --implica que encontew wl elemento buscado
}



--sabiendo que esta

function hayAlgunEn_QueCumpleCondicion(lista){
    
     elementosPorRecorrer := lista
    
    while (not ( primero(elementosPorRecorrer) == elemento)) {
        elementosPorRecorrer := sinElPrimero(elementosPorRecorrer)
    }
    
    return ( primero(elementosPorRecorrer)) 
    
}

--minimo y maximos



function transformadasTodasEnOro_(carta){
    /*
        Proposito: Describe **carta** donde cada palo de la carta cambia a Oro
        Precondicion: Ninguna
        Tipo: lista de carta
        Parametro: carta: carta
    */
    
    listaDeCartaAhora := []
    
    foreach palo in carta {
        listaDeCartaAhora := listaDeCartaAhora ++ [paloDeCarta_AOro(palo)]
    }
    return ( listaDeCartaAhora )
    
}
function paloDeCarta_AOro(cartaActual){
    /*
        Proposito: Describe la carta **cartaActual** con el valor del Palo a 
        "Oro"
        Precondicion: Ninguna
        Tipo: carta
        Parametro: carta: carta 
    */
    return(
      Carta (cartaActual | palo <- Oro)
        )
}


function opuestasDe_(listaDedireccion){
    /*
        Proposito: Describe la lista donde la **direccion** cambia a su opuesta
        Precondicion: Ninguna
        Tipo: lista de direccion
        Parametro: listaDedireccion : lista de direccion
        Observación: Es un recorrido de transformacion sobre lista de direccion,
        donde por cada elemento se le cambia a su opuesto
    */
    
    listaDireccionOpuesta := []
    
    foreach direccion in listaDedireccion {
        listaDireccionOpuesta := listaDireccionOpuesta ++ [opuesto(direccion)]
    }
    
    return (listaDireccionOpuesta)
}



function siguienteDe_(listaElementos){
    /*
        Proposito: Describe una lista de **listaDeElementos** 
        donde cada elemento es el siguiente del actual
        Precondicion: Ninguna
        Tipo: lista de "elementos"
        Parametro: listaElementos : lista de "elementos"
    */
    
    listaDeElementosActual := []
    
    foreach elemento in listaElementos {
        
        listaDeElementosActual := listaDeElementosActual ++ 
                                    [siguiente(elemento)]
        
    }
    
    return( listaDeElementosActual )
    
}






function hayAlgunoDe_Entre_Y_(listaDeNumeros, primerNumero, segundoNumero){
    /*
        Proposito: Indica si hay algun numero entre 
        **primerNumero** y **segundoNumero** en la lista 
        **listaDeNumeros** 
        Precondicion: Ninguna
        Tipo: booleano
        Parametro: listaDeNumeros  lista de Numero
        primerNumero : numero 
        segundoNumero : numero 
    */
    
    listaAVer:= listaDeNumeros
    
    while( not esVacía(listaAVer) && 
           not está_Entre_Y_(primero(listaAVer), primerNumero, segundoNumero)){
            
        listaAVer := resto(listaAVer)
               
    }
    return(not esVacía(listaAVer))
    
}

function está_Entre_Y_(numero, primeraCota, segundaCota){
    
    return(numero > primeraCota && numero < segundaCota)
        
    
}



function hayAlgunAsEn_(listaCarta){
    /*
        Proposito: Indica si en **listaCarta** hay algun AS
        Precondicion: Ninguna
        Tipo: booleano
        Parametro: listaCarta: lista de cartas
        Observacion: es un recorrido de busqueda sobre una lista de cartas,
        donde para cada carta de la lista se busca la que es un AS
    */
    
    listaAVer := listaCarta
    
    while( not esVacía(listaAVer) && not (primero(listaAVer) == 1)){
        
        listaAVer := resto(listaAVer)
    }
    return( not esVacía(listaAVer) )
}



function maximoElementoEn_(listaNumero){
    /*
        Proposito: Describe el numero más grande de la lista **listaNumero**
        Precondicion: Ninguna
        Parametro: listaNumero: lista de numero
        Tipo: numero
        Observacion es un recorrido de minimo sobre la lista **listaNumero**
        donde para cada elemento se busca el maximo
    */
    
    masGrandePorAhora := primero(listaNumero)
    
    foreach numero in sinElPrimero(listaNumero) {
        
         --masGrandePorAhora := maximoEntre_Y_(masGrandePorAhora, numero)
    }
    
    return ( masGrandePorAhora )
}


function  minimoElementoEn_(listaDeNumeros){
    
    masChicoPorAhora := primero(listaDeNumeros)
    
    foreach numero in sinElPrimero(listaDeNumeros) {
        masChicoPorAhora := minimoEntre_Y_(masChicoPorAhora, numero)
    }
    
    return(masChicoPorAhora)
}

function minimoEntre_Y_(valor1, valor2){
    /*
    Proposito: describe el valor más chico
    Precondicion: Ninguna
    Tipo: numero 
    */
    return (
        choose valor1 when (valor1 < valor2)
               valor2 otherwise
        )
}
   
function elementosEn_Hasta_(listaElementos, indice){
    
    listaHasta := []
    listaActual := listaElementos
    contador  := 1
    
    while( not esVacía(listaElementos) && not  contador ==  indice ){
        
        listaHasta := listaHasta ++ [primero(listaActual)]
        listaActual := resto(listaActual)
        contador := contador  + 1
    }
    return(listaHasta)
}



function elementosEn_Desde_(listaElementos, indice){
    /*
        Proposito: describe lalista de todos los elementos de la lista
        **listaElementos** desde el **indice**
        Precondicion: Ninguna
        Tipo: lista de "elemento"
        Parametro: listaElementos : lista de "elementos"
        Indice: "elemento"
        Observacion: Es un recorrido de transformacion de la lista actual
        desde el indice **indice**, donde para cada elemento se construye una
        nueva lista con los elementos siguientes al indice, incluyendolo
    */
    
  
    listaActual := listaElementos
    contador  := 0
    
    while( not esVacía(listaElementos) && not indice == contador){
        contador := contador + 1
        listaActual := sinElPrimero(listaActual)
    }
    return(listaActual)
}


function elementosEn_DespuesDe_(listaElementos, indice){
    /*
        Proposito: describe la lista de todos los elementos de la lista
        **listaElementos** despues del **indice**
        Precondicion: Ninguna
        Tipo: lista de "elemento"
        Parametro: listaElementos : lista de "elementos"
        Indice: "elemento"
        Observacion: Es un recorrido de transformacion de la lista actual
        desde el indice **indice**, donde para cada elemento se construye una
        nueva lista con los elementos siguientes al indice
    */
    
  
    listaActual := listaElementos
    contador := 0
    
    
    while( not esVacía(listaElementos) && not indice == contador){
        listaActual := resto(listaActual)
        contador := contador + 1
        
    }
    return(listaActual)
}


function elementosEn_SinPrimeraAparicion_(listaElemento, elemento){
    /*
        Proposito: Describe la lista **listaElemento** sin la primera
        aparicion del elemento **elemento**
        Precondicion: Ninguna
        Tipo: lista de "elemento"
        Parametro: listaElemento: lista de "elementos"
        elemento : "elemento"
    */
   
           
    return(
         elementosEn_Hasta_(listaElemento, 
                indiceEn_De_(listaElemento, elemento)) 
            ++
          elementosEn_DespuesDe_(listaElemento,
                indiceEn_De_(listaElemento, elemento))
    )
}

function sinDuplicado_(listaElemento){
    /*
        Proposito: Describe la lista **listaElemento** sin elementos duplicados
        Precondicion: Ninguna
        Tipo: lista de "elementos"
        Parametro: listaElemento : lista de "elementos"
    */
    listaSinDuplicado := []
    
    foreach elemento in listaElemento {
        
        listaSinDuplicado := listaSinDuplicado ++ 
        singular_Si_(elemento, not contiene_A_(listaSinDuplicado, elemento)) 
    }
    return ( listaSinDuplicado )
}









function indiceEn_De_(listaDeElemento, elemento){
    /*
        Proposito: Describe la primera ubicacion de la lista
        donde se encuentra el elemento **elemento**
        Precondicion: Ninguna
        Tipo: lista de elemento
        Parametro: Parametro : lista de "elemento"
        elemento : "elemento"
        Observacion: es un recorrido de busqueda sabiendo 
        que esta sobre una lista de elementos,
        donde por cada ubicacion se busca la ubicacion del elemento 
        **elemento**
    */
    
    contador := 1
    
    elementoAhora := listaDeElemento
    
    
    while ( not elemento == primero(elementoAhora)){
        
        elementoAhora := resto(elementoAhora)
        contador := contador + 1 
    }
    return ( contador )
}



function losElementosDe_Clonados_Veces(listaElementos, numero){
    /*
        Proposito: Describe la lista clonada con sus elementos
        clonados ** numero ** veces 
        Precondicion: ninguna
        Tipo: lista de "elementos"
        Parametro: listaElementos : lista de "elementos"
        numero: numero
    */
    listaClonada := []
    
    foreach elemento in listaElementos {
        listaClonada :=  listaClonada ++ 
        listaCon_Repetido_veces(elemento, numero)
    }
    return(listaClonada )
}


function laLista_Clonada_Veces( listaElemento, numero){
    /*
        Proposito: Describe la lista clonada con sus elementos en orden
        **numero** veces
        Precondicion: ninguna
        Tipo: lista de "elementos"
        Parametro: listaElementos : lista de "elementos"
        numero: numero
    */
    
    listaClonadaEnOrden := []
   

    foreach elemento in listaElemento {
        listaClonadaEnOrden := listaClonadaEnOrden ++
        elemento_Repetido_veces(listaElemento, numero) 
        
        
    }
    return (listaClonadaEnOrden )
    
}

function elemento_Repetido_veces(elemento, numero){
    /*
        Proposito: Descibre una lista que tiene el elemento 
        dado repetido tantas veces el numero dado.
        Precondicion: ninguna
        Tipo: lista de "elemento"
        Parametro: elemento: " elemento "
        numero: numero
    */
    
    elementoActual := []
    
    repeat(numero){
        elementoActual :=  elemento
    }
    
   return( elementoActual )
    
}

 
function estaOrdenada_(listaElemento){
    /*
        Proposito: Indica si la lista **lstaElemento**
        está ordenada de menor a mayor.
        Precondicion: ninguna
        Parametro: listaElementos : lista de "elementos"
    */
    
   listaAVerificar:=  listaElemento
    
    while( not esVacía(listaElemento) 
            && not esMenor_Que_( primero(listaAVerificar), 
            siguienteElementoDe_(listaElemento)) ) {
        
        listaAVerificar := sinElPrimero(listaAVerificar)            
    }
    return( esMenor_Que_( primero(listaAVerificar),
    siguienteElementoDe_(listaElemento) ) )
}

function siguienteElementoDe_(listaElemento){
    
    elementoDeListaActual := primero(listaElemento)
    
    return(siguiente(elementoDeListaActual))
    
}

function esMenor_Que_( primerElemento, segundoElemento ){
    return (primerElemento <  segundoElemento )
}






function listaCon_Repetido_veces(elemento, numero){
    /*
        Proposito: Descibre una lista que tiene el elemento
        dado repetido tantas veces el numero dado.
        Precondicion: ninguna
        Tipo: lista de "elemento"
        Parametro: elemento: " elemento "
        numero: numero
    */
    
    elementoActual := []
    
    repeat(numero){
        elementoActual := elementoActual ++ [elemento]
    }
    
   return( elementoActual )
    
}



function laLista_Ordenada(listaNumeros) {
    /*
      Proposito: describe la misma lista **listaNumeros**, con 
      los elementos ordenados.
      Precondicion: Ninguna
      Tipo: lista de numero
      Parametro: listaNumeros: lista de numero
      Observacion es un recorrido de transformacion sobre la lista
      **listaNumeros**, para ordenar los numeros de dicha lista
    */
    // copio la lista original para poder tachar los que ya
    // ordené
    listaOriginal := listaNumeros
    // acá pongo los numeros de la lista ordenada 
    listaOrdenada := []
    

    
    while( not esVacía(listaOriginal)){
        
        minimoNumero := minimoElementoEn_(listaOriginal)
        // busco el minimo entre los numeros que están en dicha lista

        listaOrdenada := listaOrdenada ++ [minimoNumero]
         
        // "BORRO" el elemento actual de la lista original
        listaOriginal := elementosEn_SinPrimeraAparicion_(listaOriginal, minimoNumero)
    }
    return( listaOrdenada )
}


function losPrimeros_De_(numero, listaDeElemento){
    /*
        Proposito: describe los **numero** primeros elemento de la lista **ListaDeNumero**
        Precondicion: ninguna
        Tipo: lista de elemento
        Parametro: numero: numero
        listaDeElemento: lista de elemento
        Observacion: Es un recorrido de filtro sobre la lista **listaDeNumero**,
        donde solo se seleccionan los primeros **numero** elemento de la lista.
    */
    
    listaActual := listaDeElemento
    
    listaSeleccionada := []
    
    contador := 0 
    
    while (not esVacía(listaActual) && contador /= numero){
        
        listaSeleccionada := listaSeleccionada ++ [primero(listaActual)]
        
        listaActual := resto(listaActual)
        
        contador := contador + 1
    }
    
    return(listaSeleccionada)
}



function lista_SinLosPrimeros_(listaDeElemento, numero){
    /*
        Proposito: Describe la lista **listaNumero** sin los primeros **numero** numeros
        Precondicion: Ninguna
        Tipo: lista de elemento
         Parametro: numero: numero
        listaDeElemento: lista de [elemento]
    */
    // return(elementosEn_DespuesDe_(listaDeElemento, numero))

    contador := 0
    listaActual := listaDeElemento
    while( not esVacía(listaActual) &&  contador < numero){
        listaActual := resto(listaActual)
        contador := contador + 1
    }
    return(listaActual)
}




function lista_AgrupadaDeA_(listaDeElementos, numero){
    /*
        Proposito: Describe una lista de listas donde cada lista interna contiene **numero** elementos
        Precondicion: Ninguna
        Tipo: lista de listas de elementos
        Parametro: listaDeElementos: lista de elementos
        numero: numero
        Observacion: es un recorrido de filtro sobre la lista **listaDeElementos** donde
        se agrupan en listas internas de **numero** elementos
    */
    listaElemento := listaDeElementos
    
    listaDeListasConElementos := []
    
    
    while( not esVacía(listaElemento)) {
        
        listaDeListasConElementos := listaDeListasConElementos ++ [losPrimeros_De_(numero, listaElemento)]
        
        listaElemento := lista_SinLosPrimeros_(listaElemento, numero)
    }
    
    return(listaDeListasConElementos)
    
}

function lista_Desagrupada(listaDeElementos){
    /*
        Proposito: Describe la lista de **listaDeElementos** sin sus listas internas.
        Precondicion: Ninguna
        Tipo: lista de elementos
        Parametro: listaDeElementos: lista de elementos
        Observacion: es un recorrido de filtro sobre la lista **listaDeElementos**, 
        dando como resultado una lista con todos los elementos del grupo en el orden dado y posición
    */
  
    listaSinListas := []
    
    foreach elemento in listaDeElementos {
         
        listaSinListas := listaSinListas ++ elemento  // devuelve todos los elementos de la lista
    }
    return(listaSinListas)
}


function combinarCadaElementoDe_Con_(priListaElem, segunListaElem){
    /*
        Proposito: Describe una lista combinando las lista **priListaElem** con **segunListaElem**
        Precondicion: Ninguna
        Tipo: listas de listas de elementos
        Parametro: priListaElem: lista de [elementos]
        segunListaElem: lista de [elementos]
        Observacion: 
    */
    
    listaCombinada := []
    
    listaUno := priListaElem
    listaDos := segunListaElem
    
    while ( not esVacía(listaUno) && not esVacía(listaDos) ){
        
        combinacionActual := [primero(listaUno), primero(listaDos)]
        
        listaCombinada := listaCombinada ++ [combinacionActual] 
        
        listaUno := resto(listaUno)
        listaDos := resto(listaDos)
        
    }
    
    return(listaCombinada)
}




// CONJUNTOS 

type Conjunto is record {
    /* PROPÓSITO: Modela un conjunto, en el sentido matemático.
    INVARIANTE DE REPRESENTACIÓN: * La lista de elementos no contiene duplicados.
    */ 
    field elementos // Lista de “Elemento” 
} 


function conjuntoCon_(listaDeElemento){
    
    /*
        Proposito: Describe un conjunto de **listaDeElemento**
        Precondicion: Ninguna
        Parametro: listaDeElemento : [elemento]
        Tipo: conjunto
    */
    
    listaSinDuplicados:= sinDuplicado_(listaDeElemento)
    
    return(Conjunto(elementos <- listaSinDuplicados) )
}

program {
    return(es_SubconjuntoDe_(conjuntoCon_([7, 21, 3]), conjuntoCon_([7, 21, 3]) ) )
}


function unionDe_Con(primConjunto, segunConjunto){
    /*
        Proposito: Describe la union de los conjuntos **primConjunto** y
        **segunConjunto**
        Precondicionn: Ninguna
        Tipo: Conjunto
        Parametro: primConjunto: Conjunto segunConjunto: Conjunto
        
    */
    
    return( conjuntoCon_(elementos(primConjunto) ++ elementos(segunConjunto) )  )
     
}



function interseccionDe_Con(primConjunto, segunConjunto){
    /*
        Proposito: Describe los elementos que están en ambos conjuntos.
        Precondicion: Ninguna
        Tipo:conjunto
        Parametro: primConjunto: Conjunto segunConjunto: Conjunto
    */
    
    return( conjuntoCon_(
                elementos_ConAparicionEn_(
                    elementos(primConjunto), elementos(segunConjunto) ) ) )
}



function es_SubconjuntoDe_(primConjunto, segunConjunto){
    /*
        Proposito: indica si los elemento de **primConjunto** 
        están en **segunConjunto**
        Precondicion: Ninguna
        Tipo: booleano
        Parametro: primConjunto: Conjunto segunConjunto: Conjunto
    */
    
    
    return( elementosDel_EstanEn_(elementos(primConjunto), elementos(segunConjunto) ) )
    
}

function elementos_ConAparicionEn_(listaAFiltrar, listaDeReferencia) {
    /* PROPÓSITO: Describe una lista con los elementos de 'listaAFiltrar'
       que TAMBIÉN aparecen en 'listaDeReferencia'.
       OBSERVACIÓN: Es un recorrido de FILTRO 
    */
    
    listaFiltrada := []
    
    foreach elemento in listaAFiltrar {
        // Usamos singular_Si_ para agregar solo si cumple la condición
        listaFiltrada := listaFiltrada ++ singular_Si_(
            elemento, 
            contiene_A_(listaDeReferencia, elemento)
        )
    }
    
    return (listaFiltrada)
}



function elementosDel_EstanEn_(primConjunto, segunConjunto){
    /*
        Proposito: Indica si los elementos de la lista **primConjunto**
        estan en la lista **segunConjunto**
        Precondicion: Ninguna
        Tipo: booleano
        Parametro:  primConjunto: Conjunto segunConjunto: Conjunto
        Obseracion: es un recorrido de busqueda sin saber si esta
        sobre dos listas, para saber si los elementos de la primera lista
        están contenidos en la segunda lista 
    */
    
    listaAVer := primConjunto
    
    while(not esVacía(listaAVer) && contiene_A_(listaAVer, primero(segunConjunto))){
        
        listaAVer := resto(listaAVer)
        
    }
    
    return(not esVacía(listaAVer))
}


type Palo is variant {
    /*
        Proposito: Modelar el palo de las cartas
    */    
    
    case Espadas {}
    case Basto {}
    case Oro {}
    case Copa {}
}

type Carta is record {
    /*
        Proposito: Modelar cartas
        ivn. rep: el numero de las cartas es del 1 al 12
    */
    
    field palo //palo
    field numero //numero
}

function laCarta_de_(paloDeCarta, numeroDeCarta){
    /*
        Proposito: Describe la carta **numeroDeCarta** de **paloDeCarta**  
        Precondicion: el numero de las cartas es del 1 al 12
        Parametro:
        *paloDeCarta: palo 
        *numeroDeCarta: numero
    */
    return(
            Carta( palo <- paloDeCarta, numero <- numeroDeCarta)
        )
}
function anchoDeEspadas() {
    /*
        Proposito: Describe la carta 1 de bastos
        Precondicion: ninguna
        Tipo: carta
    */
   return( 
        Carta( palo <- Espadas, numero <- 1 )
    )           
}


function anchoDeBastos() {
    /*
        Proposito: Describe la carta 1 de bastos
        Precondicion: ninguna
        Tipo: carta
    */
   return( 
        Carta( palo <- Basto, numero <- 1 )
    )           
}

