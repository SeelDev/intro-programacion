function esSingular_(lista){
    /*
        Proposito: Indica si la lista **lista** tiene un sólo elemento
        Precondicion: Ninguna
        Tipo: lista 
        Parametro: lista: lista de elemento
    */
    return( not esVacía(lista) && esVacía(resto(lista)) )
}

function listaCon_Repetido_veces(elemento, numero){
    /*
        Proposito: Descibre una lista que tiene el elemento dado repetido tantas veces el numero dado.
        Precondicion: ninguna
        Tipo: lista de "elemento"
        Parametro: elemento: " elemento "
        numero: numero
    */
    
    elementoActual := []
    repeat(numero){
        elementoActual := elementoActual ++ [elemento]
    }
   return( elementoActual )
}

function listaDesde_Hasta_(primerElemento, segundoElemento){
    /*
        Proposito: Describe la lista que va del **primerElemento** al **segundoElemento**, pasando por todos los elementos
        intermedios.
        Precondicion: Ninguna
        Tipo: lista de "elementos"
        Parametro: 
        primerElemento: elemento: primer "elemento" 
        segundoElemento: elemento: segundo "elemento" 
    */
    
    elementoActual := primerElemento
    listaActual:= []
    
    while(elementoActual /= segundoElemento){
        listaActual := listaActual ++ [elementoActual]
        elementoActual := siguiente(elementoActual)
    }
    listaActual := listaActual ++ [elementoActual] --casoborde
    return(listaActual)
}

function singular_Si_(elemento, condicion){
    /*
        Proposito: Describe la lista singular con el elemento dado si la condicion dada es verdadera, o la lista vacia en caso contrario.
        Precondicion: ninguna
        Parametro: elemento : "elemento"
        condicion: booleano
        Tipo: lista de "elemento"
    */
    
     return (  choose [elemento] when (condicion)
                      [] otherwise )
} 

function longitudDe_(lista){
    /*
        Proposito: Describe la cantidad de elementos que hay dentro de la lista **lista**
        Precondicion: ninguna
        Tipo: numero
        parametro: lista : lista de elementos
        Observacion: es un recorrido de acumulacion sobre la lista **lista**, para contar cuantos elementos contiene dicha lista
    */
    listaActual := lista
    cantidadDeElementosVistos := 0
    
    while(not esVacía(listaActual)){
        cantidadDeElementosVistos := cantidadDeElementosVistos + 1
        listaActual := sinElPrimero(listaActual) 
    }
    return(cantidadDeElementosVistos)
} 

function sumatoriaDe_(listaNumero){
    /*
        Proposito: Describe la suma de todos los elementos de la lista **listaNumero**
        Precondicion: Ninguna
        Tipo: numero
        Parametro: listaNumero : elemento : lista de numero
        Observacion: es un recorrido de filtro sobre la lista **listaNumero**, para sumar todos los elementos de dicha lista
    */
    
    cantidadTotalDeSuma := 0
    foreach numero in listaNumero{
        cantidadTotalDeSuma := cantidadTotalDeSuma + numero
    }
    return (cantidadTotalDeSuma )
}


function productoriaDe_(listaNumero){
    /*
        Proposito. Describe el producto de todos los elementos de **listaNumero**
        Precondicion: Ninguna
        Tipo: numero
        Parametro: listaNumero : numero : lista de numero
        Observacion: es un recorrido de filtro sobre la lista **listaNumero**, para multiplicar todos los elementos de dicha lista
    */
    cantidadTotalDeProducto := primero(listaNumero)
    foreach numero in sinElPrimero(listaNumero){
        cantidadTotalDeProducto := cantidadTotalDeProducto * numero
    }
    return (cantidadTotalDeProducto )
}

function opuestasDe_(listaDedireccion){
    /*
        Proposito: Describe la lista donde la **direccion** cambia a su opuesta
        Precondicion: Ninguna
        Tipo: lista de direccion
        Parametro: listaDedireccion : lista de direccion
        Observación: Es un recorrido de transformacion sobre lista de direccion,donde por cada elemento se le cambia a su opuesto
    */
    listaDireccionOpuesta := []
    foreach direccion in listaDedireccion {
        listaDireccionOpuesta := listaDireccionOpuesta ++ [opuesto(direccion)]
    }
    return (listaDireccionOpuesta)
}

function siguienteDe_(listaElementos){
    /*
        Proposito: Describe una lista de **listaDeElementos** donde cada elemento es el siguiente del actual
        Precondicion: Ninguna
        Tipo: lista de "elementos"
        Parametro: listaElementos : lista de "elementos"
        Observacion: es un recorrido de transformacion sbre la lista **listaElementos** donde para cada elemento es el siguiente del actual
    */
    listaDeElementosActual := []
    foreach elemento in listaElementos {
        listaDeElementosActual := listaDeElementosActual ++ 
                                    [siguiente(elemento)]
    }
    return( listaDeElementosActual )
}

function reversoDe_(lista){
    /*
        Proposito: Describe el reverso de la lista **lista**
        Precondicion: Debe haber al menos un elemento
        Tipo: lista de "elemento"
        Parametro : lista de "elemento"
        Observacion: es un recorrido de transformacion sobre una lista de elementos, donde para cada elemento se cambia al reverso
    */
    listaReversaActual := []
    foreach elemento in lista {
        listaReversaActual := [elemento] ++ listaReversaActual
    }
    return( listaReversaActual )
}

function elementosDe_SinAparicionesDe_(listaDeElemento, elemento){
    /*
        Proposito: Describe **listaDeElemento** sin el elemento **elemento**
        Precondicion: Ninguna
        Tipo: lista de "elemento"
        Parametro: Parametro : lista de "elemento"
        elemento : "elemento"
        Observacion: es un recorrido de filtro sobre lista de elemento,donde para la **listaDeElemento** se elimina todas las aparicioes de **elemento**
    */
    elementosSinAparicionesAhora := []
    foreach elementoDeLista in listaDeElemento {
        elementosSinAparicionesAhora := elementosSinAparicionesAhora ++ singular_Si_(elementoDeLista, elementoDeLista /= elemento)
    }
    return ( elementosSinAparicionesAhora )
}

function contiene_A_(listaDeElemento, elemento){
    /*
        Proposito: Indica si la lista **listaDeElemento** contiene a **elemento**
        Precondicion: Ninguna
        Tipo: booleano
        Parametro: listaDeElemento : [elemento]
        elemento: elemento
        Observacion: es un recorrido de busqueda sin saber si está sobre la lista **listaDeElemento**, donde se busca al elemento **elemento** en dicha lista
    */
    elementosPorRecorrer := listaDeElemento
    while( not esVacía(elementosPorRecorrer) && primero(elementosPorRecorrer) /= elemento) {
        elementosPorRecorrer := sinElPrimero(elementosPorRecorrer)
    }
    return ( not esVacía(elementosPorRecorrer) )
    --implica que encontre el elemento buscado
}

function maximoElementoEn_(listaNumero){
    /*
        Proposito: Describe el numero más grande de la lista **listaNumero**
        Precondicion: Ninguna
        Parametro: listaNumero: lista de numero
        Tipo: numero
        Observacion es un recorrido de maximo sobre la lista **listaNumero** donde para cada elemento se busca el maximo
    */
    masGrandePorAhora := primero(listaNumero)
    foreach numero in sinElPrimero(listaNumero) {
        masGrandePorAhora := maximoEntre_Y_(masGrandePorAhora, numero)
    }
    return ( masGrandePorAhora )
}


function  minimoElementoEn_(listaDeNumeros){
    /*
        Proposito: Describe el numero más chico de la lista **listaNumero**
        Precondicion: Ninguna
        Parametro: listaNumero: lista de numero
        Tipo: numero
        Observacion es un recorrido de minimo sobre la lista **listaNumero** donde para cada elemento se busca el minimo
    */
    masChicoPorAhora := primero(listaDeNumeros)
    foreach numero in sinElPrimero(listaDeNumeros) {
        masChicoPorAhora := minimoEntre_Y_(masChicoPorAhora, numero)
    }
    return(masChicoPorAhora)
}
   
function elementosEn_Hasta_(listaElementos, indice){
    
    listaHasta := []
    listaActual := listaElementos
    contador  := 1
    
    while( not esVacía(listaElementos) && not  contador ==  indice ){
        
        listaHasta := listaHasta ++ [primero(listaActual)]
        listaActual := resto(listaActual)
        contador := contador  + 1
    }
    return(listaHasta)
}



function elementosEn_Desde_(listaElementos, indice){
    /*
        Proposito: describe lalista de todos los elementos de la lista
        **listaElementos** desde el **indice**
        Precondicion: Ninguna
        Tipo: lista de "elemento"
        Parametro: listaElementos : lista de "elementos"
        Indice: "elemento"
        Observacion: Es un recorrido de transformacion de la lista actual
        desde el indice **indice**, donde para cada elemento se construye una
        nueva lista con los elementos siguientes al indice, incluyendolo
    */
    
  
    listaActual := listaElementos
    contador  := 0
    
    while( not esVacía(listaElementos) && not indice == contador){
        contador := contador + 1
        listaActual := sinElPrimero(listaActual)
    }
    return(listaActual)
}


function elementosEn_DespuesDe_(listaElementos, indice){
    /*
        Proposito: describe la lista de todos los elementos de la lista **listaElementos** despues del **indice**
        Precondicion: Ninguna
        Tipo: lista de "elemento"
        Parametro: listaElementos : lista de "elementos"
        Indice: "elemento"
        Observacion: Es un recorrido de transformacion de la lista actual desde el indice **indice**, donde para cada elemento se construye una nueva lista con los elementos siguientes al indice
    */
    listaActual := listaElementos
    contador := 0
    while( not esVacía(listaElementos) && not indice == contador){
        listaActual := resto(listaActual)
        contador := contador + 1
    }
    return(listaActual)
}


function elementosEn_SinPrimeraAparicion_(listaElemento, elemento){
    /*
        Proposito: Describe la lista **listaElemento** sin la primera aparicion del elemento **elemento**
        Precondicion: Ninguna
        Tipo: lista de "elemento"
        Parametro: listaElemento: lista de "elementos"
        elemento : "elemento"
    */
    return(
         elementosEn_Hasta_(listaElemento, indiceEn_De_(listaElemento, elemento)) 
            ++
          elementosEn_DespuesDe_(listaElemento, indiceEn_De_(listaElemento, elemento))
    )
}

function sinDuplicado_(listaElemento){
    /*
        Proposito: Describe la lista **listaElemento** sin elementos duplicados
        Precondicion: Ninguna
        Tipo: lista de "elementos"
        Parametro: listaElemento : lista de "elementos"
        Observacion: Es un recorrido de filtro sobre la lista **listaElemento**, donde se eliminan los elementos duplicados de dicha lista
    */
    listaSinDuplicado := []
    foreach elemento in listaElemento {
        listaSinDuplicado := listaSinDuplicado ++ singular_Si_(elemento, not contiene_A_(listaSinDuplicado, elemento)) 
    }
    return ( listaSinDuplicado )
}

function estaOrdenada_(listaElemento){
    /*
        Proposito: Indica si la lista **lstaElemento**
        está ordenada de menor a mayor.
        Precondicion: ninguna
        Parametro: listaElementos : lista de "elementos"
        Observacion: es un recorrido de busqueda sin saber si esta sobre la lista **listaElemento** donde se busca si la lista está ordenada o no
    */
    listaAVerificar:=  listaElemento
    while( not esVacía(listaElemento) && not esMenor_Que_( primero(listaAVerificar), siguienteElementoDe_(listaElemento)) ) {
        listaAVerificar := sinElPrimero(listaAVerificar)            
    }
    return( esMenor_Que_( primero(listaAVerificar), siguienteElementoDe_(listaElemento) ) )
}

function siguienteElementoDe_(listaElemento){
    elementoDeListaActual := primero(listaElemento)
    return(siguiente(elementoDeListaActual))
}

function conjuntoCon_(listaDeElemento){
    
    /*
        Proposito: Describe un conjunto de **listaDeElemento**
        Precondicion: Ninguna
        Parametro: listaDeElemento : [elemento]
        Tipo: conjunto
    */
    listaSinDuplicados:= sinDuplicado_(listaDeElemento)
    return(Conjunto(elementos <- listaSinDuplicados) )
}

function unionDe_Con(primConjunto, segunConjunto){
    /*
        Proposito: Describe la union de los conjuntos **primConjunto** y
        **segunConjunto**
        Precondicionn: Ninguna
        Tipo: Conjunto
        Parametro: primConjunto: Conjunto segunConjunto: Conjunto
        
    */
    return( conjuntoCon_(elementos(primConjunto) ++ elementos(segunConjunto) )  )
     
}

function interseccionDe_Con(primConjunto, segunConjunto){
    /*
        Proposito: Describe los elementos que están en ambos conjuntos.
        Precondicion: Ninguna
        Tipo:conjunto
        Parametro: primConjunto: Conjunto segunConjunto: Conjunto
    */
    
    return( conjuntoCon_(elementos_ConAparicionEn_(elementos(primConjunto), elementos(segunConjunto) ) ) )
}

function es_SubconjuntoDe_(primConjunto, segunConjunto){
    /*
        Proposito: indica si los elemento de **primConjunto** 
        están en **segunConjunto**
        Precondicion: Ninguna
        Tipo: booleano
        Parametro: primConjunto: Conjunto segunConjunto: Conjunto
    */
    return( elementosDel_EstanEn_(elementos(primConjunto), elementos(segunConjunto) ) )
}

function elementos_ConAparicionEn_(listaAFiltrar, listaDeReferencia) {
    /* PROPÓSITO: Describe una lista con los elementos de 'listaAFiltrar'
       que TAMBIÉN aparecen en 'listaDeReferencia'.
       OBSERVACIÓN: Es un recorrido de FILTRO 
    */
    listaFiltrada := []
    foreach elemento in listaAFiltrar {
        // Usamos singular_Si_ para agregar solo si cumple la condición
        listaFiltrada := listaFiltrada ++ singular_Si_(elemento, contiene_A_(listaDeReferencia, elemento))
    }
    return (listaFiltrada)
}

function elementosDel_EstanEn_(primConjunto, segunConjunto){
    /*
        Proposito: Indica si los elementos de la lista **primConjunto**
        estan en la lista **segunConjunto**
        Precondicion: Ninguna
        Tipo: booleano
        Parametro:  primConjunto: Conjunto segunConjunto: Conjunto
        Obseracion: es un recorrido de busqueda sin saber si esta sobre dos listas, para saber si los elementos de la primera lista están contenidos en la segunda lista 
    */
    listaAVer := primConjunto
    while(not esVacía(listaAVer) && contiene_A_(listaAVer, primero(segunConjunto))){
        listaAVer := resto(listaAVer)
    }
    return(not esVacía(listaAVer))
}