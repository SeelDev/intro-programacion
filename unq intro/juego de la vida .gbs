function esCelulaViva(){
    /*
        Proposito: Indica si la celula actual esta viva
        Precondicion: Debe haber una celula en la celda actual.
        Tipo: booleano.
    */
    
    return(hayBolitas(verde))
}
----------------------------------------------------------------------------------

function nroDeVecinasVivas(){
    /*
    Proposito: Describe la cantidad de celulas vivas que son vecinas de la celula actual.
    Precondicion: Ninguna
    Tipo: numero
    Observacion: es un recorrido de acumulacion sobre celulas vivas, para 
    obtener las celulas vivas vecinas a la celula actual
    */
    
    direccionDeCelulaVecina := minDir()
    nroDeVecinasVivasVistas := 0 
    
    nroDeVecinasVivasVistas:= nroDeVecinasVivasVistas + unoSi_ceroSiNo(hayCelulaVecinaAlDiagonal_(direccionDeCelulaVecina)) +
                              unoSi_ceroSiNo(hayCelulaVecinaAl_(direccionDeCelulaVecina) )
    
    
    while(direccionDeCelulaVecina /= maxDir()){
        
        direccionDeCelulaVecina := siguiente(direccionDeCelulaVecina)
        nroDeVecinasVivasVistas:= nroDeVecinasVivasVistas + unoSi_ceroSiNo(hayCelulaVecinaAlDiagonal_(direccionDeCelulaVecina)) +
                                 unoSi_ceroSiNo(hayCelulaVecinaAl_(direccionDeCelulaVecina) )
    
    }
    
    return(nroDeVecinasVivasVistas)
}


function hayCelulaVecinaAlDiagonal_(direccionVecina){
    /*
        Proposito: Indica si hay una celula vecina al diagonal **direccionVecina** de la celula viva actual-
        Precondicion: Ninguna
        Parametro:
        *direccionVecina : direccion : direccion vecina de la celula actual
        Tipo: booleano
    */
    
    return(
        puedeMover(direccionVecina) &&
        puedeMover(siguiente(direccionVecina)) &&
        esCelulaVivaAlDiagonal_(direccionVecina))
        )
}

function hayCelulaVecinaAl_(direccionVecina){
    /*
        Proposito: Indica si hay una celula vecina al **direccionVecina** de la celula viva actual-
        Precondicion: Ninguna
        Parametro:
        *direccionVecina : direccion : direccion vecina de la celula actual
        Tipo: booleano
    */
    
    return(
        puedeMover(direccionVecina) && esCelulaVivaAl_(direccionVecina))
        )
}



function esCelulaVivaAlDiagonal_(direccionVecinaDiagonal){
    /*
        Proposito: Indica si hay una celula viva al diagonal **direccionVecinaDiagonal**
        de la celula actual.
        Precondicion: Ninguna
        Parametro:
        *direccionVecinaDiagonal : direccion : direccion vecina al  diagonal de la celula actual
        Tipo: Booleano
    */
    
    Mover(direccionVecinaDiagonal) 
    Mover(siguiente(direccionVecinaDiagonal))
    
    return(esCelulaViva())
}



function esCelulaVivaAlDiagonal_(direccionVecina){
    /*
        Proposito: Indica si hay una celula viva al **direccionVecinaDiagonal**
        de la celula actual.
        Precondicion: Ninguna
        Parametro:
        *direccionVecina: direccion : direccion vecina  de la celula actual
        Tipo: Booleano
    */
    
    Mover(direccionVecinaDiagonal)
    return(esCelulaViva())
}

--------------------------------------------------------------------------


procedure PrepararCelulaActual(){
    /*
        Proposito: Marcar la celula actual para ser eliminada o reanimada.
        Precondicion: Ninguna
        Observacion: es un recorrido de procesamiento sobre el universo, 
        marcando las celulas que deben ser reanimadas o eliminadas.
    */
    
    IrAPrimeraCelula() 
    
    while(haySiguienteCelula()){
        
        MarcarCelulaAcá()
        IrASiguienteCelula()
    }
    
    MarcarCelulaAcá()
}


procedure MarcarCelulaAcá(){
    /*
        Proposito: Marcar la celula actual en caso que deba ser reanimada o
        eliminada.
        Precondicion: Debe haber al menos una celula en la celda actual.
    
    */
    
    if(esCelulaViva() &&
            ( (nroDeVecinasVivas < 2)  
                || (nroDeVecinasVivas > 3)  ) {
        
        MarcarCélulaParaSerEliminada()
    }
    
    elseif (not esCelulaViva() && nroDeVecinasVivas == 3) {
        
        MarcarCélulaParaSerReanimada()
    }
   
}



procedure CompletarElPróximoTick() {
    /*
        Proposito: Leer y procesar todas marcas ( de reanimacion y eliminacion)
        de todas las celulas.
        Precondicion: Debe haber al menos una marca de eliminacion o reanimacion
        en la celula actual.
        Observacion : es un recorrido de procesamiento sobre celulas del universo, 
        para eliminar o reanimar cada celula marcada
    */
    
    IrAPrimeraCelula()
    
    while(haySiguienteCelula()){
        
        ProcesarMarcaEnLaCelula()
        IrASiguienteCelula()
    }
    
    ProcesarMarcaEnLaCelula()
}


procedure ProcesarMarcaEnLaCelula(){
    /*
        Proposito: procesar la marca que contenga la celula actual.
        Precondicion: debe haber una celula marcada en la celda actual.
    */
    
    if (not esCelulaViva() && estáMarcadaParaSerEliminada()){
        
        EliminarCélula()
    }
    elseif( not esCelulaViva() && estáMarcadaParaSerReaminada()){
        
        ReanimarCélula()
    }
    
}



procedure Simular_Ticks(cantidad) {
    /*
        Proposito: Simula **cantidad** ticks sobre el universo.
        Precondicion: Ninguna
        Observacion recorrido de procesamiento sobre el universo, 
        simulando **cantidad** de ticks.
    */
    
    contandorDeTicksHechos := 0
    
    IrAPrimeraCelula()
    
    while( haySiguienteCelula() && 
            not contandorDeTicksHechos == cantidad) {
                
        CompletarElPróximoTick()
        contandorDeTicksHechos := contandorDeTicksHechos + 1 
    }
    CompletarElPróximoTick()
}













function cantidadDeVecinasConBolitas(){
    /*
    Proposito: Describe la cantidad de celda vecinas que tienen al menos una bolita de algun color.
    Precondicion: Ninguna
    Tipo: numero
    Observacion: Es un recorrido de acumulacion sobre celdas vecinas del tablero, para obtener
    la cantidad de celdas con alguna bolita de cualquier color
    */
    --Inicializo el recorrido enumerativo : direccion
    direccionCeldaVecina := minDir()
    -- Inicializo acumulador de las celdas vecinas con bolitas tanto como las ortogonales como las diagonales
    celdasVecinasYaContadas := 0
    
    celdasVecinasYaContadas :=  celdasVecinasYaContadas + unoSi_ceroSiNo(hayCeldaVecinaConBolitasAl_(direccionCeldaVecina))
                                                       + unoSi_ceroSiNo(hayCeldaDiagonalVecinaConBolitasAl_(direccionCeldaVecina))
    
    -- while : mientras la direccion minima no sea igual a la maxima
    while( direccionCeldaVecina /= maxDir()){
        direccionCeldaVecina := siguiente(direccionCeldaVecina) -- actualizo variable de direccion
        --actualizo variable de acumulador de las celdas vecinas con bolitas (ortogonales y diagonales) 
        celdasVecinasYaContadas := celdasVecinasYaContadas + unoSi_ceroSiNo(hayCeldaVecinaConBolitasAl_(direccionCeldaVecina))
                                                            + unoSi_ceroSiNo(hayCeldaDiagonalVecinaConBolitasAl_(direccionCeldaVecina))
    }
    celdasVecinasYaContadas := celdasVecinasYaContadas + unoSi_ceroSiNo(hayCeldaVecinaConBolitasAl_(direccionCeldaVecina))
                                                            + unoSi_ceroSiNo(hayCeldaDiagonalVecinaConBolitasAl_(direccionCeldaVecina))
  return ( celdasVecinasYaContadas ) -- retorno la variable que acumulo todas las celdas con bolitas
}
   
   
function hayCeldaVecinaConBolitasAl_(direccionVecina){
    /*
    Proposito: Indica si hay una celda vecina al direccionVecina desde la celda actual.
    Precondicion: Ninguna
    Tipo: booleano
    Parametro: 
    *direccionVecina: direccion: direccion de la direccion vecina ortogonal
    */
    --retorno un circuito corto, primero pregunto si me puedo mover a dicha direccion dada por la variable
    --y despues me muevo y pregunto si es una celda con bolitas
    return (puedeMover(direccionVecina) && esCeldaVecinaConBolitasAl_(direccionVecina))
}

function hayCeldaDiagonalVecinaConBolitasAl_(direccionVecina){
    /*
    Proposito: Indica si hay una celda diagonal vecina al direccionVecina desde la celda actual.
    Precondicion: Ninguna
    Tipo: booleano
    Parametro: 
    *direccionVecina: direccion: direccion de la direccion vecina diagonal
    */
    --retorno un circuito corto, primero pregunto si me puedo mover a dicha direccion dada en diagonal por la variable
    --y despues me muevo y pregunto si es una celda con bolitas (o sea tambie pregunto por la siguiente direccion)
    return (
            puedeMover(direccionVecina) && 
            puedeMover(siguiente(direccionVecina)) && 
            esCeldaVecinaDiagonalConBolitasAl_(direccionVecina)
    )
}
--Pregunto de manera ortogonal si en la celda dada por variable tiene al menos una bolita de algun color
function esCeldaVecinaConBolitasAl_(direccionVecinaOrtogonal){
    /*
    Proposito: Indica si en la celda al direccionVecinaOrtogonal hay una celda que tenga almenos una 
    bolita de algun color.
    Precondicion: Ninguna
    Tipo: booleano
    Parametro:
    *direccionVecinaOrtogonal: direccion: direccion de la direccion vecina ortogonal
    */
    Mover(direccionVecinaOrtogonal)
    --retorno de forma booleana si es una celda con alguna bolita
    return(esCeldaConBolitas())
}

--Pregunto de manera diagonal si la celda dada por variable tiene al menos una bolita de algun color
function esCeldaVecinaDiagonalConBolitasAl_(direccionVecinaDiagonal){
    /*
    Proposito: Indica si en la celda al direccionVecinaDiagonal hay una celda que tenga almenos una 
    bolita de algun color.
    Precondicion: Ninguna
    Tipo: booleano
    Parametro:
    *direccionVecinaDiagonal: direccion: direccion de la direccion vecina diagonal
    Observacion: la celda vecina "diagonal" se construye con dicha direccion y su -siguiente- direccion
    */
    Mover(direccionVecinaDiagonal)
    Mover(siguiente(direccionVecinaDiagonal))
    --retorno de forma booleana si es una celda con alguna bolita
    return(esCeldaConBolitas())
}

